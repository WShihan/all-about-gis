[{"content":"效果 截图 实例 思路 查阅网上文章得知实现控高分析涉及ClassificationPrimitive（不懂中文怎么翻译它，暂叫基元吧）， CallbackProperty 这两个关键类，前者是一个分类基元，表示要在场景中突出显示的包围几何体的体积（分析中指定高度以外建筑的高亮效果）。后者是一个特殊属性，它的值由调用异步函数获取，可动态变化（在此分析中实现指定高度以内建筑高亮效果以及高度面变化）。\n整理分析操作流程如下：\n绘制一个范围面。 创建一个ClassificationPrimitive（基元）对象表示区域内高度超限，及两个几何面Entity （实体）对象，其中一个Entity设置为贴地且分类属性设置为3DTiles表示区域内高度不超限，另一个不贴地，表示高度面。 修改高度，两个Entit拉伸高度以及基元位置同步变化。 难点 Entity实现拉伸高度变化比较容易，但ClassificationPrimitive位置动态变化无法借助CallbackProperty，而是直接修改位置矩阵，有个问题是，必须要给基元拉伸高度设置一个很高的高度值，以至于能够覆盖最高的建筑。\n示例代码下载 控高分析 (xiemolin233.cn)\n参考： Cesium限高分析_cesium 限高分析-CSDN博客\nCesium中实现限高分析 - 槑的秘密基地 (liaomz.top)\n","date":"2025-03-13T00:00:00Z","permalink":"https://wshihan.github.io/all-about-gis/p/cesium%E9%99%90%E9%AB%98%E5%88%86%E6%9E%90/","title":"Cesium限高分析"},{"content":"文章 1.什么是GIS 关于什么是GIS，下面是一些比较权威的机构它的定义。\n【中文】什么是 GIS？ | 地理信息系统制图技术\n【中文】什么是地理信息系统（GIS）？ 开源地理空间基金会中文分会 开放地理空间实验室 【英文】What is GIS? | Geographic Information System Mapping Technology\n2.Pie in the sky 【英文】Pie in the sky 介绍Arcgis pro中一种新的饼状图例，和传统饼图不一样的是，每个部分不是用半径来划分，而是采用弧度，看起来像是阴晴圆缺的月亮一般。\n3.Cesium阴影率分析 【中文】Cesium阴影率分析 作者参考超图SDK实现的阴影率分析，效果看起来很不错，完成度很高。\n4.Cesium-通视分析 【中文】Cesium-通视分析 本文介绍一种基于Cesium的简单通视分析。\n5.红绿灯倒计时功能是如何实现的？ 【中文】高德地图官方首度揭秘：红绿灯倒计时功能是如何实现的？ 有次打车的时候，我注意到了这个功能，当时想的是导航软件是不是和交通部门有合作，可以实时获取每个红绿灯的状态及变化秒数，导本文介绍了其中原理，居然是大数据相关的技术，另外B站上一位地理教授发表的一个视频也涉及到这个。\n6.在运行MacOS系统的电脑上安装QGIS 【英文】How to Install QGIS on a Mac Computer 可能大部分人第一次接触的GIS软件是ArcGIS，但是官方没有发布过MacOS版本，如果你使用的是以上系统，那么可以尝试下QGIS，它是开源的，功能很强大，不需要商业许可或者昧着良心破解，本文就是教你如何安装它。\n7.空间插值 【中文】ArcGIS的插值方法有哪些区别，分别适合哪些情况\n介绍常见空间插值以及不同维度间的对比，总结其适用性和局限性。\n8.来自 Esri 的超强制图专家的“秘密”武器 【中文】]来自 Esri 的超强制图专家的“秘密”武器！\n作者对ESRI公司出品的地形处理工具做了改进。\n9.利用开放地理信息系统数据绘制公共城市绿地地图 【英文】Using Open GIS Data to Map Public Urban Green Spaces\n介绍如何使用开放地图数据以及相关方法识别公共绿地并绘制出地图。\n10.GIS行业相关的证书 【英文】Certification in GIS\n介绍GIS行业内的一些证书，主要是国外。\n工具 1.GeoServer 一款非常流行的开源地图服务器。\n2.GeocodeCN 一款基于百度地图开放平台的QGIS插件，可以批量将地址转换为经纬度，支持不同经纬度，包括百度做标题，WGS84，国测局坐标系。\n3.Qgis2threejs 一个QGIS插件，支持导入数字高程模型（DEM）及矢量，栅格数据生成场景后，导出在浏览器里浏览，下图为我以前项目的截图（大理苍山地区）。\n4.GeoDjango Django是一个用Python编写的网络应用开发框架，而GeoDjango则是在基础上增强GIS功能的版本，旨在成为世界级的地理Web框架，其目标是尽可能轻松地构建地理信息系统Web应用程序并利用空间使能数据的力量。我曾经用过Django，而GeoDjango则没有，我的博客的第一个版本就是采用了前者。此项目文档，功能什么的都挺完备，希望以后有机会能实践一下。\n数据分享 版权声明：自由转载-非商用-非衍生-保持署名（创意共享3.0许可证）\n","date":"2025-03-13T00:00:00Z","permalink":"https://wshihan.github.io/all-about-gis/p/issue/","title":"vol · 1"},{"content":"文章 1.多视角航空图像中对地理空间对象进行分类的方法 【英文】Multiview aerial imagery for geospatial object classification | by adhiguna mahendra | Jun, 2024 | Medium 介绍一种利用语义网格从多视角航空图像中对地理空间对象进行分类的新方法，将其与传统方法进行对比，并探讨其在林业和农业中的商业应用。\n2.ArcGIS Pro3.3 对CAD和BIM支持的新变化 【英文】What’s new for CAD and BIM in ArcGIS Pro 3.3 ArcGIS Pro对CAD和BIM支持的新变化。\n3.不正当抓取高德地图“拥堵延时指数”，被判赔偿1250万 【中文】不正当抓取高德地图“拥堵延时指数”，被判赔偿1250万 国内一家金融公司通过爬虫手段爬取高德地图“拥挤延时指数”数据用于盈利，被告后一审认定不正当竞争赔付1250万。 “拥堵延时指数”大致可以理解为道路上的车辆实际通行时间与完全畅通情况下车辆通行时间的比值。比值越高，城市拥堵程度越严重；比值越低，城市拥堵情况越轻微。\n4.俄罗斯和美国在地理上仅相隔 2.4 英里但时间上 相隔21 小时 【英文】These Two Countries are Separated by 2.4 Miles and 21 Hours 俄罗斯和美国在地理上仅相隔 2.4 英里但时间上 相隔21 小时\n5.比较地图投影 【英文】比较地图投影 介绍地图投影并分享观点的博客\n6.ArcGIS Pro土地勘测定界软件V2.9简介 【中文】ArcGIS Pro土地勘测定界软件V2.9简介 专绘领域软件介绍\n7.ArcGIS 故事地图新功能介绍 【英文】Explore the Newest Additions to StoryMaps ArcGIS 故事地图新功能介绍。\n8.蓝皮书文章丨信息技术应用创新背景下地理信息系统技术的现状与发展展望 【中文】蓝皮书文章丨信息技术应用创新背景下地理信息系统技术的现状与发展展望 地理信息技术展望\n9.绘制红树林物种地图如何帮助减缓海岸侵蚀 【英文】绘制红树林物种地图如何帮助减缓海岸侵蚀 一些红树林物种在保护沿海地区以及为社区提供重要资源方面变得至关重要。它们的损失可能对这些社区有害;然而，如果没有更好的地图数据和改进的建模，就不可能了解这种损失。\n10.地理空间的革命和自动化 【英文】地理空间的革命和自动化 介绍地理空间领域的最新创新和自动化趋势，看看AI是如何引起浪潮。\n11.如何查找ArcGIS Online Web地图的URL并将其添加到QGIS 【中文】如何查找ArcGIS Online Web地图的URL并将其添加到QGIS ArcGIS Online上托管有许多精美的地图，在制作地图时，如果没有合适的底图，不妨在上面找找看，本文介绍如何获取ArcGIS Online上的在线地图服务地址，然后添加到QGIS项目。\n12.如何在ArcGIS Online查找数据并添加到QGIS 【英文】How to Add Data from ArcGIS Online to QGIS 教程，如何在ArcGIS Online查找数据并添加到QGIS。\n13.如何在QGIS使用ESRI文件地理数据库 【英文】How to Use Esri File Geodatabases in QGIS 一篇教授如何在QGIS使用ESRI文件地理数据库的教程。\n14.openrouteservice插件更新 【英文】openrouteservice插件更新 openrouteservice是一款开源的QGIS插件，提供一系列路径分析功能，文章介绍此次插件更新的内容\n15.QGIS插件更新 【英文】QGIS插件更新 2024年3月至4月，QGIS插件发布列表。\n数据分享 1.覆盖欧盟和英国的OSM土地利用数据 OSM Landuse Data is available in HeiData – GIScience Blog 覆盖欧盟和英国的OSM土地利用数据，通过深度学习对Sentinel-2影像识别得到。\n版权声明：自由转载-非商用-非衍生-保持署名（创意共享3.0许可证）\n","date":"2025-03-13T00:00:00Z","permalink":"https://wshihan.github.io/all-about-gis/p/vol2/","title":"vol·2"},{"content":"","date":"2025-03-13T00:00:00Z","permalink":"https://wshihan.github.io/all-about-gis/p/issue/","title":"vol·3"},{"content":"文章 1.postgis几何函数汇总 【中文】postgis几何函数汇总 postgis几何函数汇总\n2.重设GeoServer账号密码 【中文】重设GeoServer账号密码 geoserver忘记密码后如何重设密码，亲测有效。\n3.低空是否需要不一样的天路一张图？ 【中文】低空是否需要不一样的天路一张图？ 有点意思\n4.利用PlanetScope卫星影像绘制莫干湖（安卡拉）水质参数 【中文】利用PlanetScope卫星影像绘制莫干湖（安卡拉）水质参数 利用PlanetScope卫星影像绘制莫干湖（安卡拉）水质参数\n5.为视障人士制作3D打印的步道地图 【中文】为视障人士制作3D打印的步道地图 为视障人士制作3D打印的步道地图\n6.QGIS 4月～5月插件更新列表 【英文】QGIS 4月～5月插件更新列表 QGIS插件更新列表，4月～5月\n7.免费在线无人机 GeoTiff 查看器 【英文】免费在线无人机 GeoTiff 查看器 免费在线无人机 GeoTiff 查看器\n8.如何生成像谷歌高德一样的切片地图 【中文】如何生成像谷歌高德一样的切片地图 简单介绍如何用qgis将地图切片\n9.普通克里金插值方法动画演示 【英文】普通克里金插值方法动画演示 油管上一个关于普通克里金插值法到动画演示视频\n工具 1.ogr2ogr ogr2ogr 一款基于gdal的空间数据格式转换命令行工具，使用简单且格式支持广泛。\n2.QTiles QTiles 一款QGIS插件，生成预设的栅格瓦片地图。\n3.Bunting Labs AI Vectorizer Bunting Labs AI Vectorizer 一款QGIS插件，借助AI赋能，可以帮助在传统的栅格地图上快速将地理要素矢量化。该插件为商业公司开发，提供有免费使用额度。\n版权声明：自由转载-非商用-非衍生-保持署名（创意共享3.0许可证）\n","date":"2025-03-13T00:00:00Z","permalink":"https://wshihan.github.io/all-about-gis/p/issue/","title":"vol·3"},{"content":"文章 1.What is the Difference Between Geospatial Data and Attribute Data in GIS? 【英文】What is the Difference Between Geospatial Data and Attribute Data in GIS?[3] 科普向，介绍GIS数据中，空间数据和属性数据的不同。\n2.Generating a stylized city map with Python 【英文】Generating a stylized city map with Python[4] 使用开源的python工具包绘制带杨样式的地图，和prettymaps类似，有一定的艺术性。\n3.GIS Showdown! Comparing Google Maps, OpenStreetMap, and More 【中文】GIS Showdown! Comparing Google Maps, OpenStreetMap, and More[5] 不同GIS平台/软件系统对比。\n4.What is the use of LiDAR in remote sensing? 【英文】What is the use of LiDAR in remote sensing?[6] 科普向，介绍激光雷达在遥感中的应用。\n5.DIY Vector Tile Server with Postgres, FastAPI and Async SQLAlchemy 【英文】DIY Vector Tile Server with Postgres, FastAPI and Async SQLAlchemy[7] 介绍了如何使用FastAPI、PostGIS和Async SQLAlchemy构建一个简单的矢量瓦片服务器。矢量瓦片是一种轻量级的数据格式，用于存储地理空间矢量数据，例如点、线和多边形。通过构建矢量瓦片服务器，可以提高地图数据的可视化效率和速度。\n6.Sky-rocket your productivity in QGIS 【英文】Sky-rocket your productivity in QGIS[8] QGIS教程，如何利用脚本自动话制作地图。\n7.Fluvial Beauty. A blend of classical approach and up to… 【英文】[Fluvial Beauty. A blend of classical approach and up to…(https://medium.com/@prasatyaizza/fluvial-beauty-cac6eb988666[9]) 河流之美——科普向文章，介绍如何使用GIS分析河流。\n8.Nautical chart creation is versatile with ArcGIS Maritime 【英文】Nautical chart creation is versatile with ArcGIS Maritime[10] 使用ESRI产品以自动化形式制作航海图。\n9.Top 5 Tips to Improve Your Feature Layer Performance 【英文】Top 5 Tips to Improve Your Feature Layer Performance[11] 来自ESRI开发人员的分享，如何提高要素图层的性能，我觉得其中的建议跳出ESRI产品之外也受用。\n10.The Importance of Java in Advancing Geo-Spatial Technology 【英文】The Importance of Java in Advancing Geo-Spatial Technology[12] Java在推进地里空间技术中的重要性。\n工具 1.探索遥感影像app 探索遥感影像app[13] ESRI出品的网页应用，探索影像（主要是Sentinel），可以做到查看时相影像，变化监测等。\n2.Plugin Update Plugin Update[14] QGIS 发布于2024年6月份的插件\n","date":"2025-03-13T00:00:00Z","permalink":"https://wshihan.github.io/all-about-gis/p/issue/","title":"vol·4"},{"content":"文章 1.GeoParquet in QGIS – smaller \u0026amp; faster files for the win! | Free and Open Source GIS Ramblings 【英文】GeoParquet in QGIS – smaller \u0026amp; faster files for the win! | Free and Open Source GIS Ramblings[3] 一种新的列式数据格式，比CSV更小，读取速度更快。\n2.Plugin Update – August, 2024 – QGIS.org blog 【英文】Plugin Update – August, 2024 – QGIS.org blog[4] Qgis八月份插件更新名单\n3.使用Python剪切和可视化NetCDF数据 【英文】使用Python剪切和可视化NetCDF数据[5] 使用Python剪切和可视化NetCDF数据的教程。\n4.Golang 在 GIS 中的应用 【英文】Golang 在 GIS 中的应用[6] 简要描述Golang 在 GIS 中的应用。\n工具 1.ORM Tutorial — GeoAlchemy2 0.2.6 documentation ORM Tutorial — GeoAlchemy2 0.2.6 documentation[7] GeoAlchemy在SQLAlchemy的基础上，提供空间数据操作能力\n2.Rzezimioszek/QGIS-easy-filter-selection: QGIS plugin gives easy selecting and filter feature for users that don\u0026rsquo;t want writes comlicated sql for simple problem. Rzezimioszek/QGIS-easy-filter-selection: QGIS plugin gives easy selecting and filter feature for users that don\u0026rsquo;t want writes comlicated sql for simple problem.[8] 该QGIS插件允许用户在不编写复杂的SQL语句的情况下来过滤要素\n3.Rzezimioszek/QGIS-style-exporter: This extension for QGIS 3+ gives user batch option for saving layers style to individual files with name as layer name. Rzezimioszek/QGIS-style-exporter: This extension for QGIS 3+ gives user batch option for saving layers style to individual files with name as layer name.[9] 该QGIS插件支持批量将图层样式导出为单独文件\n4.gisinnovationmy/FeatureTransferTool gisinnovationmy/FeatureTransferTool[10] 该QGIS插件允许快速地在图层之间复制和粘贴要素\n5.GISInternals Support Site GISInternals Support Site[11] 该网站提供有GDAL及MapServer和相关项目的二进制文件。\n","date":"2025-03-13T00:00:00Z","permalink":"https://wshihan.github.io/all-about-gis/p/issue/","title":"vol·5"},{"content":"文章 1.跟着做教程，使用FastAPI创建空间API 【英文】链接 [3] 教程，使用FastAPI框架搭建支持空间处理的网络接口。我常常使用flask搭建一些快速实现的需求，感觉这个不错，有机会尝试一下看看。\n2.Gridded NetCDF基础-使用ArcGIS模拟气候变化 【英文】链接 [4] 介绍如何使用ArcGIS Pro分析NOAA提供的以NetCDF格式存储的气候数据，模拟气候变化。\n3.在QGIS中对Landsat影像做全色锐化处理 【英文】链接[5] 文章介绍全色锐化，一种广泛使用的技术，用于提高多光谱卫星图像的空间分辨率。该过程将卫星图像的高分辨率全色波段与较低分辨率的多光谱波段相结合，生成视觉上细节丰富的图像，同时不丢失颜色信息。\n4.如何利用Python对DEM沉陷区进行填平 【英文】链接 [6] 本文介绍了如何使用Python处理数字地形模型（DEM）中的沉陷区（sinks）。沉陷区是由于DEM数据中的错误海拔值造成的，这些错误值比正常值低。文章提供了两种方法来填充这些沉陷区：一种是无条件填充所有沉陷区，另一种是设置阈值，仅填充满足特定高度差的沉陷区。这些方法有助于提高水文分析的准确性，并避免水流积聚和不规则地表形态。\n5.WebGIS 三维空间分析之参考超图实现的天际线分析 【中文】链接[7] 作者通过比较原生Cesium和超图发行版的实现，提出了利用深度图获取天际线坐标的新思路，并讨论了场景内绘制天际线和二维线段图表的方法，提供了具体的实现效果展示。\n6.使用动力学和地图对GPS数据进行插值 【英文】链接 [8] 这篇文章讨论了如何使用地图和运动学数据对GPS数据进行插值，以提高地理空间数据集的分辨率。作者介绍了一种类似于航位推算的方法，通过车辆的速度信号和地图信息来推断GPS信号缺失时的地理位置。文章详细解释了插值过程，包括地图匹配、地图对齐、速度整合和地图投影等技术，并提供了一个案例研究，展示了如何使用插值后的GPS数据来识别车辆急刹车的路段。最后，作者还提供了实现这一过程的Python代码，并讨论了如何使用这些数据进行进一步的分析。\n7.如何将栅格像素值提取到对应点 【英文】链接[9] 作者使用ArcGIS来实现，但是也可以用其他GIS软件来实现，因为逻辑一样的。\n工具 1.Godview 链接[10] 一个结合AI实现的语义化地图，用自然语言查询地图，你可以模糊查询一个地区的信息，发现自阮老师的周刊。\n下图是我查询的结果。\n2.Spatial Reference List 链接[11] 该网站提供空间坐标系列表，可以获取不同的坐标系描述格式，例如wkt,proj等，获取坐标系描述信息之后便于互相转换。\n3.3dtiles 链接[12] 3D-Tile 转换工具集，支持将多种类型的地理空间数据格式转换为3Dtile（一种由Cesium主导的开源数据格式）的命令行工具。\n","date":"2025-03-13T00:00:00Z","permalink":"https://wshihan.github.io/all-about-gis/p/issue/","title":"vol·6"},{"content":"近些天，有一个项目需要对大量的地理数据进行统计，然后在前端展示，作为组里为数不多拥有GIS专业背景的人，毫无意外地任务又落在我身上。\n该任务统计过程其实简单，难点在于数据量实在是太大，还要经过空间运算、采样后才能着手统计，而且需求端（前端）的目的一开始不是很明确，扔过来一个截图文件，先是统计这个、后又统计那个、再这个，统计后交换数据结构也是时常变化，本来数据量就大，前后折腾耗了很多时间，又一个面向口头约定编程的经典案例。\n如果是小量数据，直接无脑上GIS软件就行，可是它不行，所以我想着写份代码一劳永逸地解决诸如此类的问题，此时眉头一皱，GDAL 涌上心头。\n我打算用GDAL 去解决，发现当数据格式为gdb时，它会将整个数据全部读取，但是数据量太大导致异常卡顿，每次读取都要十几分钟，无奈只能将gdb里的每一个图层提取出来，形成一个个的shapefile文件，GDAL 具备空间数据格式转换的能力，同时它还提供了一个超级方便的命令行工具，ogr2ogr（OGR包含自GDAL ，一个用来处理矢量格式数据的库，而GDAL 主要是处理栅格）。\n初识ogr2ogr 从pypi上下载的GDAL Python包，安装后是没有[ogr2ogr](https://www.osgeo.cn/GDAL /prOGRams/ogr2ogr.html)的，需前往[Download — GDAL documentation](https://GDAL .org/download.html#current-release)，根据系统下载预编译好的版本，在系统高级设置-\u0026gt;环境变量中设置好相关OGR变量后，即可在命令行工具中全局调用。\n格式转换：gdb -\u0026gt;shapefile 命令行格式\n1 ogr2ogr -f out_put_format output_directory path_to_gdb output_format：输出格式\noutput_directory：输出保存路径\npath_to_gdb：指定的gdb文件保存路径\n示例\n1 ogr2ogr -f \u0026#34;ESRI Shapefile\u0026#34; D:\\extracted D:\\Geodatabase.gdb 执行该命令后，D:\\Geodatabase.gdb 中的所有图层都会被提取并以 Shapefile 格式保存在指定的输出路径中。\nogr2ogr裁剪 使用 下面是ogr2ogr裁剪命令格式\n1 ogr2ogr -clipsrc clip_file output_file input_file clip_file：用于裁剪的图层所在路径 output_file：结果输出路径 input_file：被裁剪图层所在路径 示例\n1 ogr2ogr -clipsrc E:\\Desktop\\assets\\waters.shp E:\\Desktop\\clip_test\\out.shp E:\\Desktop\\clip_test\\M5_120_0_0000__2D_Zones.shp 注：上述三者文件类型均为shapefile\n潜在问题 如果使用上述命令行过程中出现ERROR 6: GEOS support not enabled错误提示，并且在裁剪输出图层内无任何要素，\n1 ERROR 6: GEOS support not enabled 原因是OGR并没有对特征之间的空间关系计算提供原生支持，该功能依赖另一个C++库——GEOS。GEOS 是一个用于地理空间计算的库，它在 GDAL 中负责处理几何计算任务，包括裁剪。如果在编译 GDAL 时未启用 GEOS 支持，将无法使用裁剪功能。\n要解决此问题，可以尝试重新编译和安装 GDAL ，并确保在配置和编译过程中启用 GEOS 支持，或者前往GISInternals Support Site下载预编译好，且支持GEOS的GDAL 版本。\n批量裁剪 ogr2ogr 待处理文件数量很多，如何批量裁剪，目前我能使出三种方法，第一种还是使用ogr2ogr，但它作为命令行工具，如何才能批量获取shapefile文件，然后批量调用它执行裁剪呢，既然是命令行，肯定是写bat脚了，但是那玩意我不会，所以借助Python，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import subprocess import os def batch_clip(): out_root = r\u0026#39;output_file_root_path\u0026#39; clip_file = r\u0026#39;path_to_clip_shapefile\u0026#39; for root, folders, files in os.walk(r\u0026#39;all_shapefile_path\u0026#39;): for f in files: if f.endswith(\u0026#39;.shp\u0026#39;): input_file = root + \u0026#39;\\\\\u0026#39; + f output_file = out_root + \u0026#39;\\\\\u0026#39; + f print(\u0026#34;{:-^30}\u0026#34;.format(f)) # 构造 ogr2ogr 命令 command = [\u0026#39;ogr2ogr\u0026#39;, \u0026#39;-clipsrc\u0026#39;, clip_file, output_file, input_file] # 执行命令 subprocess.call(command) print(\u0026#39;============完成==============\u0026#39;) ArcPy ArcGIS中，几乎每一个地理人估计都有的工具，它执行空间裁剪相当简单，其批处理程序具备解决重复性操作的能力，但是数量上升到成百上千时，效率不高，故借用它的Python开发包进行定制批处理操作。\n注意：ArcGIS内置Python2，版本太老，语法和3不兼容，诸如文件路径出现中文等小细节会导致各种各样的问题，弃用，选择它的理由也就是地理人人手一个，唾手可得，不用再装其他依赖。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # -*- coding: cp936 -*- import os import arcpy clip = r\u0026#34;path_to_clip_shapefile\u0026#34; for root, folders, files in os.walk(r\u0026#39;shapefile_path\u0026#39;): for f in files: if f.endswith(\u0026#39;.shp\u0026#39;): print(\u0026#39;----%s\u0026#39; % f) input_file = root + \u0026#39;\\\\\u0026#39; + f output_file = root + \u0026#39;\\\\\u0026#39; + \u0026#39;clipped\u0026#39; + \u0026#39;\\\\\u0026#39; + f # 读取裁剪范围的几何对象 with arcpy.da.SearchCursor(clip, [\u0026#34;SHAPE@\u0026#34;]) as cursor: for row in cursor: clip_geometry = row[0] # 执行裁剪 arcpy.Clip_analysis(input_file, clip_geometry, output_file) 定义输入输出变量如下，\ninput_file:输出图层的文件路径\noutput_file: 和裁剪范围的文件路径\nclip_feature:裁剪图层。\n然后，使用 arcpy.da.SearchCursor() 从裁剪范围图层中获取几何对象。在此示例中，假设裁剪范围图层只有一个要素，因此使用了 for 循环来遍历记录并获取 SHAPE@ 字段的值（即几何对象）。\n最后，使用 arcpy.Clip_analysis() 函数执行裁剪操作，将输入图层按照裁剪范围进行裁剪，并保存到输出图层中。\n请注意替换示例代码中的文件路径为实际的文件路径，并确保已经设置好 ArcGIS 环境以及相关的许可证。\nGeopandas Geopandas是一个新兴的，基于Python的地理空间处理包，（看名字就知道它和pandas有瓜葛）同样支持空间裁剪操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import geopandas as gpd import os for root, folders, files in os.walk(r\u0026#39;shapefile_path\u0026#39;): for f in files: if f.endswith(\u0026#39;.shp\u0026#39;): print(\u0026#39;----%s\u0026#39; % f) # 读取输入图层和裁剪图层 input_layer = gpd.read_file(root + \u0026#39;\\\\\u0026#39; + f) clip_layer = gpd.read_file(r\u0026#39;path_to_clip_layer\u0026#39;) output_name =root + r\u0026#34;\\cliped_\u0026#34; + f # 进行裁剪操作 output_layer = gpd.clip(input_layer, clip_layer) # 将裁剪结果保存为新图层 output_layer.to_file(output_name) print(\u0026#39;============完成==============\u0026#39;) 这样，空间运算的部分结束，之后再统一遍历所有的shapefile，统计目标信息就行了。\n参考 GDAL (OGR)库与GEOS库的协作 开源地理空间基金会中文分会 开放地理空间实验室 (osgeo.cn) 小助手（一个基于chatGPT的微信机器人) ","date":"2025-03-13T00:00:00Z","permalink":"https://wshihan.github.io/all-about-gis/p/%E6%89%B9%E9%87%8F%E8%A3%81%E5%89%AA%E7%9F%A2%E9%87%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E5%87%A0%E7%A7%8D%E9%80%94%E5%BE%84/","title":"批量裁剪矢量数据的几种途径"},{"content":"翻译自:https://www.codeproject.com/Articles/114797/Polyline-Simplification#headingDPN\n整个记录关于算法的部分是翻译来的，原作者实现的语言是C++，但是我看不懂这类代码，于是自己用Python实现了一遍，其中可能会有错误的地方，欢迎指出来让我改正。\n[TOC]\n1 2 3 4 from shapefile import Reader, Writer import numpy as np import math import matplotlib.pyplot as plt 1 2 # 该shapefile文件内含一条线段，坐标系为：3857 shp = Reader(\u0026#39;./vector/lyr_line.shp\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) 1 2 feat = shp.shape(0) line = np.array(feat.points) 1 2 3 4 5 6 7 # 保存为shapefile文件 def shpGen(fileName, pts): w = Writer(fileName, encoding=\u0026#39;utf-8\u0026#39;, shapeType=3) w.fields = shp.fields w.line([pts]) w.record(\u0026#34;测试\u0026#34;, 3) w.close() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # 点到线距离 def point2lineDistance(x0,y0,x1,y1,x2,y2): a =x2 -x1 b = y2 - y1 c = b*x1- a*y1 return abs(a*y0 - b*x0 + c) / math.sqrt(a*a + b*b) # return abs((x2-x1)*(y1-y0)-(x1-x0)*(y2-y1)) / math.sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1)) # 点到点距离 def point2pointDistance(x1,y1,x2,y2): dx = x2-x1 dy = y2-y1 return math.sqrt(dx*dx+dy*dy) # 绘制 def plotLine(pts, simplifyLst, newlabel:str): plt.figure(figsize=(15, 6)) plt.plot(pts[:,0], pts[:,1], \u0026#39;r-*\u0026#39;, linewidth=0.5, mfc=\u0026#39;red\u0026#39;, mec=\u0026#39;red\u0026#39;, label=\u0026#39;origin\u0026#39;) plt.plot(simplifyLst[:,0], simplifyLst[:,1], \u0026#39;b-s\u0026#39;, linewidth=0.5, mfc=\u0026#39;blue\u0026#39;, mec=\u0026#39;blue\u0026#39;, label=newlabel) plt.legend(loc=\u0026#39;upper left\u0026#39;) plt.show() Radial Distance 该算法是一个时间复杂度为${O(n)}$的暴力算法。在连续的顶点中，与当前某一个key（简化过程中标记保留的顶点）的距离太近时会被去掉。\n起止顶点一般会保留作为简化线的一部分，故标记为key，从第一个key（第一个顶点）开始，算法将遍历整条线段，所有连续顶点中，移除那些距离不超过容忍值的顶点，而第一个超过容忍值的顶点将标记为下一个key，从新key开始，算法重新遍历余下的点并重复上述过程，直到最后一个点。\n1 2 3 4 5 6 7 8 9 10 11 def NearestSimplify(tolorence:float, pts:list) -\u0026gt; list: start = 0 validFlags = np.zeros((len(pts), ), dtype=\u0026#34;bool\u0026#34;) for i in range(1, len(pts)): dist = math.sqrt(math.pow(pts[i][0]- pts[start][0], 2) + math.pow(pts[i][1] - pts[start][1], 2)) if dist \u0026gt; tolorence: validFlags[i] = True start = i validFlags[0] = True return validFlags 1 2 flags = NearestSimplify(20, feat.points) plotLine(line, line[flags], \u0026#34;Radial Distance\u0026#34;) 1 2 flags = NearestSimplify(10, feat.points) plotLine(line, line[flags], \u0026#34;Radial Distance\u0026#34;) Perpendicular Distance 临近点算法将点-点距离作为误差判据，而垂直距离简化则是将点-线段的距离作为误差判据。对于每个顶点Vi，需要计算它与线段[Vi-1， Vi+1]的垂直距离，距离小于给定容忍值的点将被移除。过程如下图所示：\n最开始处理前三个顶点，计算第二个顶点的垂直距离，与容忍值作比较，大于则标记为key。然后算法往前移动开始处理下一个前三个顶点，第二次距离小于容忍值，移除中间顶点。重复直到处理所有顶点。\n注意：对于每个被移除的顶点Vi，下一个可能被移除的候选顶点是Vi+2。这意味着原始多段线的点数最多只能减少50%。为了获得更高的顶点减少率，需要多次遍历。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def PerpendicularSimplify(tolorence:float, pts:list) -\u0026gt; list: sp = 0 ep = 2 validFlags = np.zeros((len(pts), ), dtype=\u0026#34;bool\u0026#34;) for i in range(1, len(pts) - 1): verDist = point2lineDistance( pts[i][0], pts[i][1], pts[sp][0], pts[sp][1], pts[ep][0], pts[ep][1]) if verDist \u0026gt; tolorence: validFlags[i] = True sp = i ep = i + 2 validFlags[0] = validFlags[-1] = True return validFlags 1 2 perLine = PerpendicularSimplify(20, feat.points) plotLine(line, line[perLine], \u0026#34;Perpendicular Distance\u0026#34;) 1 2 perLine = PerpendicularSimplify(10, feat.points) plotLine(line, line[perLine], \u0026#34;Perpendicular Distance\u0026#34;) Reumann-Witkam 该算法使用点-线距离作距离判断。首先定义一条线段，起止点为原始线段的前两个顶点，对于每一个连续的顶点vi，计算它与前述线段的垂直距离，当距离超过容忍值时，将顶点vi - 1标记为key。顶点vi和vi + 1用来定义新的线段，算法重复直到最后一个点。下图为算法演示：\n红色的条带由指定的容忍值生成，而线段则由原始线的前两个顶点生成。第三个顶点不在红色条带内，意味着该顶点是一个key。通过第二，三顶点定义新的条带，位于条带内的最后一个顶点也标记为key，而其他点则移除。算法重复直到新吊带包含原始线段的最后一个顶点。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def ReuWitkamSimplify(tolorence:float, pts:list) -\u0026gt; list: sp = 0 ep = 1 validFlags = np.zeros((len(pts), ), dtype=\u0026#34;bool\u0026#34;) for i in range(2, len(pts)): verDist = point2lineDistance( pts[i][0], pts[i][1], pts[sp][0], pts[sp][1], pts[ep][0], pts[ep][1]) if verDist \u0026gt; tolorence: validFlags[i-1] = True sp = ep ep = i validFlags[0] = validFlags[-1] = True return validFlags 1 2 rLine = ReuWitkamSimplify(20, feat.points) plotLine(line, line[rLine], \u0026#34;Reumann-Witkam\u0026#34;) 1 2 rLine = ReuWitkamSimplify(10, feat.points) plotLine(line, line[rLine], \u0026#34;Reumann-Witkam\u0026#34;) Opheim Ophein 使用 最小和最大距离容忍值来约束搜索区域。对于连续的顶点${v_i}$，它与当前${key}$（通常是${v_0}$)的径向距离可以被计算出来。在容忍值范围内的最后一个顶点被用来定义一条射线${R(v_{key} , v_i)}$，如果这样的顶点不存在，那么射线将被定义为${R(v_{key} , v_{key + 1})}$。计算每一个连续的顶点${v_j}$（在${v_i}$后边）与射线${R}$ 间的垂直距离， 当该距离超过最小容忍值或者当${v_j}$与${v_k}$间的辐射距离大于最大容忍值时，在${v_{j-1}}$位置上的顶点，将被认为是一个新${key}$。\n值得注意的是，关于如何定义射线${R(v_{key},v_i)}$ 去控制搜索区域的方法存在多个，可能的方法有如下几种：\nReumann-Witkam 的方法 : ${i}$ = ${key}$ + 1. 外部第一个点：${key}$ \u0026lt; ${i}$ 且${v_i}$ 是第一个掉落在最小辐射距离外部的点. 内部最后一个点：${key}$ \u0026lt; ${i}$ 且 ${v_i}$ 是掉落在最小辐射距离内的最后一个点；若该点不存在，则使用方法1. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def opheimSimplify(minTolorence:int, maxTolorence:int, pts) -\u0026gt; list: vKey = 0 validPtsLst = np.zeros((len(pts),), dtype=\u0026#39;bool\u0026#39;) for i in range(vKey, len(pts)): if point2pointDistance(pts[vKey][0], pts[vKey][1], pts[i][0], pts[i][1]) \u0026gt; minTolorence: vi = i break for j in range(vi + 1, len(pts)): vj2rayDist = point2lineDistance( pts[j][0], pts[j][1], pts[vKey][0], pts[vKey][1], pts[vi][0], pts[vi][1]) radialDist = point2pointDistance(pts[vKey][0], pts[vKey][1], pts[j][0], pts[j][1]) if vj2rayDist \u0026lt;= minTolorence or radialDist \u0026gt; maxTolorence: vKey = j - 1 validPtsLst[j-1] = True else: continue validPtsLst[0] = validPtsLst[-1]= True return np.array(validPtsLst) 1 2 opheim = opheimSimplify(2, 20, np.array(feat.points)) plotLine(line, line[opheim], \u0026#34;opheim\u0026#34;) 1 2 opheim = opheimSimplify(2, 10, np.array(feat.points)) plotLine(line, line[opheim], \u0026#34;opheim\u0026#34;) Lang Lang 简化算法定义一个固定大小的搜索区域，它的第一个和最后一个点来自线段的同一个片段——用来计算处于中间的顶点的垂直距离。若任何计算出的距离大于指定的容忍值，那么搜索区域将通过排除其最后一个顶点进行收缩，这个过程会一直重复直到所有垂直距离小于特定的容忍值，或者中间顶点全部排除。所有中间节点移除后，新的搜索区域将以旧搜索区域的最后一个点作为起点进行构建。\nThe search region is constructed using a look_ahead value of 4. For each intermediate vertex, its perpendicular distance to the segment S (v0, v4) is calculated. Since at least one distance is greater than the tolerance, the search region is reduced by one vertex. After recalculating the distances to S (v0, v3), all intermediate vertices fall within the tolerance. The last vertex of the search region v3 defines a new key. This process repeats itself by updating the search region and defining a new segment S (v3, v7).\n搜索区域使用前四个顶点来生成。计算每一个中间顶点到片段S(v0, v4)的垂直距离，只要至少存在一个顶点的垂直距离超过容忍值，搜索区域便简化一个顶点。再重复计算中间顶点到片段S(v0, v3)，所有的中间顶点到片段S的垂直距离都位于容忍值内，搜索区域的最后一个顶点v3作为一个新key同时它也用来定义一个新的区域（片段）S(v3, v7)。\n第一个点作为vKey,创建片段S(v0, v4) 求中间顶点到片段的垂直距离 片段依次排除最后一个顶点（当距离超过容忍值） 片段内无顶点的垂直距离超过容忍值，此时最后一个点作为新key，同时构建新片段 重复1-4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def langSimplify(tolorence, pts, steps=0) -\u0026gt; list: vKey = 0 end = 2 validLst = np.zeros((len(pts),), dtype=\u0026#39;bool\u0026#39;) if(steps == 0): maxSteps = len(pts) - 1 else: maxSteps = steps while vKey \u0026lt; maxSteps and end \u0026lt; maxSteps: isBigger = False # print(\u0026#34;segment:(%s，%s)\u0026#34; % (vKey, end)) for i in range(vKey + 1, end): perDist = point2lineDistance( pts[i][0], pts[i][1], pts[vKey][0], pts[vKey][1], pts[end][0], pts[end][1]) if perDist \u0026gt; tolorence: isBigger = True end -= 1 break else: continue if not isBigger: vKey = end end += 2 validLst[vKey] = True validLst[0] = validLst[-1] = True return validLst 1 2 langLine = langSimplify(20, feat.points, steps=0) plotLine(line, line[langLine], \u0026#34;Lang\u0026#34;) 1 2 langLine = langSimplify(10, feat.points, steps=0) plotLine(line, line[langLine], \u0026#34;Lang\u0026#34;) Douglas-Peucker Douglas-Peucker算法使用点-边距离作为误差衡量标准。该算法从连接原始Polyline的第一个和最后一个顶点的边开始，计算所有中间顶点到边的距离，距离该边最远的顶点，如果其距离大于指定的公差，将被标记为Key并添加到简化结果中。这个过程将对当前简化中的每条边进行递归，直到原始Polyline的所有顶点与当前考察的边的距离都在允许误差范围内。该过程如下图所示:\n初始时，简化结果只有一条边（起点-终点）。第一步中，将第四个顶点标记为一个Key，并相应地加入到简化结果中；第二步，处理当前结果中的第一条边，到该边的最大顶点距离低于容差，因此不添加任何点；在第三步中，当前简化的第二个边找到了一个Key（点到边的距离大于容差）。这条边在这个Key处被分割，这个新的Key添加到简化结果中。这个过程一直继续下去，直到找不到新的Key为止。注意，在每个步骤中，只处理当前简化结果的一条边。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def douglasPeuckerSimplify(tolorence, pts) -\u0026gt; list: start = 0 end = len(pts) - 1 def findPt(start, end): curPt = 0 maxDist = 0 for i in range(start + 1, end): perpenDist = point2lineDistance( pts[i][0], pts[i][1], pts[start][0], pts[start][1], pts[end][0], pts[end][1]) if perpenDist \u0026gt; maxDist: maxDist = perpenDist curPt = i if maxDist \u0026gt; tolorence: preKey = findPt(start, curPt) postKey = findPt(curPt, end) return [] + preKey + postKey else: return [pts[end]] return [pts[0]] + findPt(start, end) 1 2 res = douglasPeuckerSimplify(20, feat.points) plotLine(line, np.array(res), \u0026#34;Douglas-Peucker\u0026#34;) 1 2 res = douglasPeuckerSimplify(10, feat.points) plotLine(line, np.array(res), \u0026#34;Douglas-Peucker\u0026#34;) 1 2 res = douglasPeuckerSimplify(5, feat.points) plotLine(line, np.array(res), \u0026#34;Douglas-Peucker\u0026#34;) ​ ​\n","date":"2020-09-09T00:00:00Z","permalink":"https://wshihan.github.io/all-about-gis/p/%E7%BA%BF%E6%AE%B5%E7%AE%80%E5%8C%96%E7%9A%84%E5%87%A0%E7%A7%8D%E7%AE%97%E6%B3%95/","title":"线段简化的几种算法"}]